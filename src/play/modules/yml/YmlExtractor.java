/**
 *  This file is part of LogiSima.
 *
 *  LogiSima is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  LogiSima is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with LogiSima.  If not, see <http://www.gnu.org/licenses/>.
 */
package play.modules.yml;

import java.beans.PropertyVetoException;
import java.io.File;
import java.io.FileOutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.Date;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Id;
import javax.persistence.Lob;

import org.apache.log4j.Level;
import org.hibernate.ejb.Ejb3Configuration;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import play.Logger;
import play.Play;
import play.db.jpa.JPASupport;
import play.db.jpa.Model;
import play.utils.Utils;

import com.mchange.v2.c3p0.ComboPooledDataSource;

public class YmlExtractor {
    
    private static final String TAB = "    ";

    public static void main(String[] args) throws Exception {
        // we initiate play! framework
        File root = new File(System.getProperty("application.path"));
        Play.init(root, System.getProperty("play.id", ""));

        // we retrieve parameters
        String filename = "data";
        String output = "conf/";
        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith("--")) {
                if (args[i].startsWith("--filename=")) {
                    filename = args[i].substring(11);
                }
                if (args[i].startsWith("--output=")) {
                    output = args[i].substring(9);
                }
            }
        }

        // get an entityManager to acces play DB
        EntityManager em = iniateJPA();

        // we create the file
        File file = new File(output + "/" + filename + ".yml");
        FileOutputStream fop = new FileOutputStream(file);
        fop.write("# Generated by logisima-play-yml (http://www.logisima.com) \n".getBytes());
        
        // Init YAML 
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        Yaml yaml = new Yaml(options);
        
        // we search all entities classes
        List<Class> entities = Play.classloader.getAnnotatedClasses(Entity.class);
        for (Class entity : entities) {
            Logger.info("Generate YML for class :" + entity.getCanonicalName());
            fop.write("\n###############################################################".getBytes());
            fop.write(("\n# " + entity.getCanonicalName()).getBytes());
            fop.write("\n###############################################################\n".getBytes());

            
            // we search all object for the specified class
            List<JPASupport> objects = (List<JPASupport>) em.createQuery("select e from " + entity.getCanonicalName() + " as e").getResultList();
            for (JPASupport jpaSupport : objects) {

                Logger.info("Generate YML for class id :" + getObjectId(jpaSupport));
                fop.write(("\n" + jpaSupport.getClass().getCanonicalName() + "(" + getObjectId(jpaSupport) + "):\n").getBytes());

                for (java.lang.reflect.Field field : jpaSupport.getClass().getFields()) {
                    Map<String, Object> data = new HashMap<String, Object>();
                    String name = field.getName();
                    if (!name.equals("id") && !name.equals("willBeSaved")) {
                        // if field is a List
                        if (List.class.isInstance(field.get(jpaSupport))) {
                            List myList = (List) field.get(jpaSupport);
                            String[] tmpValues = new String[myList.size()];
                            for (int i = 0; i < myList.size(); i++) {
                                tmpValues[i] = getObjectId(myList.get(i));
                                
                            }
                            data.put(name, tmpValues);
                        } else {
                            // if field is a Map
                            if (Map.class.isInstance(field.get(jpaSupport))) {
                                Map myMap = (Map) field.get(jpaSupport);
                                String[] tmpValues = new String[myMap.size()];
                                Iterator it = myMap.entrySet().iterator();
                                int i = 0;
                                while (it.hasNext()) {
                                    Object myObj = it.next();
                                    tmpValues[i] = getObjectId(myObj);
                                    i++;
                                }
                                data.put(name, tmpValues);
                            }
                            else {
                                // if field is a Set
                                if(Set.class.isInstance(field.get(jpaSupport))){
                                    Set mySet = (Set) field.get(jpaSupport);
                                    String[] tmpValues = new String[mySet.size()];
                                    Iterator it = mySet.iterator();
                                    int i = 0;
                                    while (it.hasNext()) {
                                        Object myObj = it.next();
                                        tmpValues[i] = getObjectId(myObj);
                                        i++;
                                    }
                                    data.put(name, tmpValues);
                                }
                                // otherwise, it's normal field
                                else{
                                    String tmpValue = field2Yml(jpaSupport, field);
                                    data.put(name, tmpValue);
                                }
                            }
                        }
                        String value = yaml.dump(data).replaceAll("^", TAB);
                        // a little hack for scalar ... I have to find a better solution
                        value = value.replaceAll("- ", TAB + "- ");
                        fop.write(value.getBytes());
                    }
                }
            }
        }
        fop.flush();
        fop.close();
    }

    /**
     * Convert a (simple, not a scalar) field to a string for yml value.
     *  
     * @param jpaSupport
     * @param field
     * @return
     * @throws IllegalArgumentException
     * @throws IllegalAccessException
     * @throws ParseException
     */
    private static String field2Yml(Object jpaSupport, Field field) throws IllegalArgumentException, IllegalAccessException, ParseException {
        String value = "" + field.get(jpaSupport);

        // if Lob annotation, then bigtext
        if (field.isAnnotationPresent(Lob.class)) {
            value = field.get(jpaSupport).toString();
        }

        // if field is an object that extend Model
        if (Model.class.isInstance(field.get(jpaSupport))) {
            value = getObjectId(field.get(jpaSupport));
        }
        
        // if field is a date
        if(Date.class.isInstance(field.get(jpaSupport))){
            SimpleDateFormat sdf = new SimpleDateFormat("yy-MM-dd hh:mm:ss");
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
            Date myDate = (Date) sdf.parse(field.get(jpaSupport).toString());
            value = df.format(myDate);
        }

        return value;
    }

    /**
     * Method that return an indentifer for the object.
     * 
     * @param Object
     * @return the id field value
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     */
    private static String getObjectId(Object object) throws IllegalArgumentException, IllegalAccessException {
        JPASupport jpaSupport = (JPASupport) object;
        String objectId = null;
        // if the object extend from the play's model class
        if (jpaSupport instanceof Model) {
            // we take the model id
            objectId = ((Model) jpaSupport).getClass().getSimpleName() + "_" + ((Model) jpaSupport).id.toString();
        }
        // else we try to get value of the field with id annotation
        else {
            // we look up for the field with the id annotation
            Field fieldId = null;
            for (java.lang.reflect.Field field : jpaSupport.getClass().getFields()) {
                if (field.getAnnotation(Id.class) != null) {
                    fieldId = field;
                }
            }
            if (fieldId != null) {
                objectId = fieldId.get(jpaSupport).toString();
            }
        }

        return objectId;
    }

    /**
     * Method to get the DB dialect. Note: this method is a copy of play!
     * framework code (but it's private ...)
     * 
     * @param driver
     * @return String
     */
    private static String getDefaultDialect(String driver) {
        if (driver.equals("org.hsqldb.jdbcDriver")) {
            return "org.hibernate.dialect.HSQLDialect";
        } else if (driver.equals("com.mysql.jdbc.Driver")) {
            return "play.db.jpa.MySQLDialect";
        } else {
            String dialect = Play.configuration.getProperty("jpa.dialect");
            if (dialect != null) {
                return dialect;
            }
            throw new UnsupportedOperationException("I do not know which hibernate dialect to use with " + driver + ", use the property jpa.dialect in config file");
        }
    }

    /**
     * Method that return a Play EntytManager. Note: this method is a copy of
     * play! framework code.
     * 
     * @return EntityManager
     * @throws PropertyVetoException
     */
    private static EntityManager iniateJPA() throws PropertyVetoException {
        Properties p = Play.configuration;
        ComboPooledDataSource ds = new ComboPooledDataSource();
        ds.setDriverClass(p.getProperty("db.driver"));
        ds.setJdbcUrl(p.getProperty("db.url"));
        ds.setUser(p.getProperty("db.user"));
        ds.setPassword(p.getProperty("db.pass"));
        ds.setAcquireRetryAttempts(1);
        ds.setAcquireRetryDelay(0);
        ds.setCheckoutTimeout(Integer.parseInt(p.getProperty("db.pool.timeout", "5000")));
        ds.setBreakAfterAcquireFailure(true);
        ds.setMaxPoolSize(Integer.parseInt(p.getProperty("db.pool.maxSize", "30")));
        ds.setMinPoolSize(Integer.parseInt(p.getProperty("db.pool.minSize", "1")));
        ds.setTestConnectionOnCheckout(true);

        List<Class> classes = Play.classloader.getAnnotatedClasses(Entity.class);
        Ejb3Configuration cfg = new Ejb3Configuration();
        cfg.setDataSource(ds);
        if (!Play.configuration.getProperty("jpa.ddl", "update").equals("none")) {
            cfg.setProperty("hibernate.hbm2ddl.auto", Play.configuration.getProperty("jpa.ddl", "update"));
        }
        cfg.setProperty("hibernate.dialect", getDefaultDialect(Play.configuration.getProperty("db.driver")));
        cfg.setProperty("javax.persistence.transaction", "RESOURCE_LOCAL");
        if (Play.configuration.getProperty("jpa.debugSQL", "false").equals("true")) {
            org.apache.log4j.Logger.getLogger("org.hibernate.SQL").setLevel(Level.ALL);
        } else {
            org.apache.log4j.Logger.getLogger("org.hibernate.SQL").setLevel(Level.OFF);
        }
        // inject additional hibernate.* settings declared in Play!
        // configuration
        cfg.addProperties((Properties) Utils.Maps.filterMap(Play.configuration, "^hibernate\\..*"));

        try {
            Field field = cfg.getClass().getDeclaredField("overridenClassLoader");
            field.setAccessible(true);
            field.set(cfg, Play.classloader);
        } catch (Exception e) {
            Logger.error(e, "Error trying to override the hibernate classLoader (new hibernate version ???)");
        }
        for (Class<? extends Annotation> clazz : classes) {
            if (clazz.isAnnotationPresent(Entity.class)) {
                cfg.addAnnotatedClass(clazz);
                Logger.trace("JPA Model : %s", clazz);
            }
        }
        String[] moreEntities = Play.configuration.getProperty("jpa.entities", "").split(", ");
        for (String entity : moreEntities) {
            if (entity.trim().equals(""))
                continue;
            try {
                cfg.addAnnotatedClass(Play.classloader.loadClass(entity));
            } catch (Exception e) {
                Logger.warn("JPA -> Entity not found: %s", entity);
            }
        }
        Logger.trace("Initializing JPA ...");
        EntityManagerFactory entityManagerFactory = cfg.buildEntityManagerFactory();
        return entityManagerFactory.createEntityManager();
    }

}
