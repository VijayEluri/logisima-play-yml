/**
 *  This file is part of LogiSima.
 *
 *  LogiSima is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  LogiSima is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with LogiSima.  If not, see <http://www.gnu.org/licenses/>.
 */
package play.modules.yml;

import java.beans.PropertyVetoException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Map.Entry;

import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Id;
import javax.persistence.Lob;

import org.apache.log4j.Level;
import org.hibernate.ejb.Ejb3Configuration;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import play.Logger;
import play.Play;
import play.db.jpa.JPASupport;
import play.db.jpa.Model;
import play.modules.yml.models.YmlObject;
import play.utils.Utils;

import com.mchange.v2.c3p0.ComboPooledDataSource;

/**
 * Util class for logisima-yml module.
 * 
 * @author bsimard
 *
 */
public class YmlExtractorUtil {
    
    private static final String TAB = "    ";
    
    /**
     * Method that generate the YLM file.
     * 
     * @param output
     * @param filename
     * @param myHash
     * @throws IOException
     */
    public static void writeYml(String output, String filename, HashMap<String, YmlObject> objectMap) throws IOException{
        // we create the file
        File file = new File(output + "/" + filename + ".yml");
        FileOutputStream fop = new FileOutputStream(file);
        fop.write("# Generated by logisima-play-yml (http://www.logisima.com) \n".getBytes());
        Iterator it = objectMap.entrySet().iterator();
        String tmp = "";
        while (it.hasNext()) {
            Entry object = (Entry) it.next();
            tmp = writeObject2Yml(object);
            fop.write(tmp.getBytes());
        }
        fop.flush();
        fop.close();
    }
    
    /**
     * Recursive method to write object.
     */
    public static String writeObject2Yml(Object object){
        String ymlText = "";
        return ymlText;
    }
    
    public static YmlObject object2YmlObject(JPASupport jpaSupport) throws IllegalArgumentException, IllegalAccessException, ParseException{
        // Init YAML 
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        Yaml yaml = new Yaml(options);
        
        // Initialization of YmlObject
        YmlObject ymlObject = new YmlObject();
        ymlObject.setId(YmlExtractorUtil.getObjectId(jpaSupport));

        //String value for the object
        String stringObject = "\n" + jpaSupport.getClass().getCanonicalName() + "(" + YmlExtractorUtil.getObjectId(jpaSupport) + "):\n";
        Logger.info("Generate YML for class id :" + YmlExtractorUtil.getObjectId(jpaSupport));
        for (java.lang.reflect.Field field : jpaSupport.getClass().getFields()) {
            
            // map that will contain all object field
            Map<String, Object> data = new HashMap<String, Object>();
            
            String name = field.getName();
            Boolean valueIsSet = Boolean.FALSE;
            
            if (!name.equals("id") && !name.equals("willBeSaved")) {
               
                // if field is a List
                if (List.class.isInstance(field.get(jpaSupport))) {
                    List myList = (List) field.get(jpaSupport);
                    String[] tmpValues = new String[myList.size()];
                    for (int i = 0; i < myList.size(); i++) {
                        tmpValues[i] = YmlExtractorUtil.getObjectId(myList.get(i));
                        // if myObj is an entity, we add it to children
                        if (Model.class.isInstance(myList.get(i))) {
                            ymlObject.getChildren().add(getObjectId(myList.get(i)));
                        }
                    }
                    data.put(name, tmpValues);
                    valueIsSet = Boolean.TRUE;
                } 
                
                // if field is a Map
                if (Map.class.isInstance(field.get(jpaSupport))) {
                    Map myMap = (Map) field.get(jpaSupport);
                    String[] tmpValues = new String[myMap.size()];
                    Iterator it = myMap.entrySet().iterator();
                    int i = 0;
                    while (it.hasNext()) {
                        Object myObj = it.next();
                        tmpValues[i] = YmlExtractorUtil.getObjectId(myObj);
                        // if myObj is an entity, we add it to children
                        if (Model.class.isInstance(myObj)) {
                            ymlObject.getChildren().add(getObjectId(myObj));
                        }
                        i++;
                    }
                    data.put(name, tmpValues);
                    valueIsSet = Boolean.TRUE;
                }
            
                // if field is a Set
                if(Set.class.isInstance(field.get(jpaSupport))){
                    Set mySet = (Set) field.get(jpaSupport);
                    String[] tmpValues = new String[mySet.size()];
                    Iterator it = mySet.iterator();
                    int i = 0;
                    while (it.hasNext()) {
                        Object myObj = it.next();
                        tmpValues[i] = YmlExtractorUtil.getObjectId(myObj);
                        // if myObj is an entity, we add it to children
                        if (Model.class.isInstance(myObj)) {
                            ymlObject.getChildren().add(getObjectId(myObj));
                        }
                        i++;
                    }
                    data.put(name, tmpValues);
                    valueIsSet = Boolean.TRUE;
                }
                
                // if Lob annotation, then bigtext
                if (field.isAnnotationPresent(Lob.class)) {
                    data.put(name, field.get(jpaSupport).toString());
                    valueIsSet = Boolean.TRUE;
                }

                // if field is an object that extend Model
                if (Model.class.isInstance(field.get(jpaSupport))) {
                    ymlObject.getChildren().add(getObjectId(field.get(jpaSupport)));
                    data.put(name, getObjectId(field.get(jpaSupport)));
                    valueIsSet = Boolean.TRUE;
                }
                
                // if field is a date
                if(Date.class.isInstance(field.get(jpaSupport))){
                    SimpleDateFormat sdf = new SimpleDateFormat("yy-MM-dd hh:mm:ss");
                    DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
                    Date myDate = (Date) sdf.parse(field.get(jpaSupport).toString());
                    data.put(name, df.format(myDate));
                    valueIsSet = Boolean.TRUE;
                }
                
                // otherwise ...
                if(!valueIsSet){
                    String tmpValue =  "" + field.get(jpaSupport);
                    data.put(name, tmpValue);
                }
                
                // yml indentation
                String value = yaml.dump(data).replaceAll("^", TAB);
                // a little hack for scalar ... I have to find a better solution
                value = value.replaceAll("- ", TAB + "- ");
                stringObject += value;
            }
        }
        ymlObject.setYmlValue(stringObject);
        
        return ymlObject;
    }
    
    /**
     * Method that return an id for the object.
     * 
     * @param Object
     * @return the id field value
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     */
    public static String getObjectId(Object object) throws IllegalArgumentException, IllegalAccessException {
        JPASupport jpaSupport = (JPASupport) object;
        String objectId = null;
        // if the object extend from the play's model class
        if (jpaSupport instanceof Model) {
            // we take the model id
            objectId = ((Model) jpaSupport).getClass().getSimpleName() + "_" + ((Model) jpaSupport).id.toString();
        }
        // else we try to get value of the field with id annotation
        else {
            // we look up for the field with the id annotation
            Field fieldId = null;
            for (java.lang.reflect.Field field : jpaSupport.getClass().getFields()) {
                if (field.getAnnotation(Id.class) != null) {
                    fieldId = field;
                }
            }
            if (fieldId != null) {
                objectId = fieldId.get(jpaSupport).toString();
            }
        }

        return objectId;
    }

    /**
     * Method to get the DB dialect. Note: this method is a copy of play!
     * framework code (but it's private ...)
     * 
     * @param driver
     * @return String
     */
    public static String getDefaultDialect(String driver) {
        if (driver.equals("org.hsqldb.jdbcDriver")) {
            return "org.hibernate.dialect.HSQLDialect";
        } else if (driver.equals("com.mysql.jdbc.Driver")) {
            return "play.db.jpa.MySQLDialect";
        } else {
            String dialect = Play.configuration.getProperty("jpa.dialect");
            if (dialect != null) {
                return dialect;
            }
            throw new UnsupportedOperationException("I do not know which hibernate dialect to use with " + driver + ", use the property jpa.dialect in config file");
        }
    }

    /**
     * Method that return a Play EntytManager. Note: this method is a copy of
     * play! framework code.
     * 
     * @return EntityManager
     * @throws PropertyVetoException
     */
    public static EntityManager iniateJPA() throws PropertyVetoException {
        Properties p = Play.configuration;
        ComboPooledDataSource ds = new ComboPooledDataSource();
        ds.setDriverClass(p.getProperty("db.driver"));
        ds.setJdbcUrl(p.getProperty("db.url"));
        ds.setUser(p.getProperty("db.user"));
        ds.setPassword(p.getProperty("db.pass"));
        ds.setAcquireRetryAttempts(1);
        ds.setAcquireRetryDelay(0);
        ds.setCheckoutTimeout(Integer.parseInt(p.getProperty("db.pool.timeout", "5000")));
        ds.setBreakAfterAcquireFailure(true);
        ds.setMaxPoolSize(Integer.parseInt(p.getProperty("db.pool.maxSize", "30")));
        ds.setMinPoolSize(Integer.parseInt(p.getProperty("db.pool.minSize", "1")));
        ds.setTestConnectionOnCheckout(true);

        List<Class> classes = Play.classloader.getAnnotatedClasses(Entity.class);
        Ejb3Configuration cfg = new Ejb3Configuration();
        cfg.setDataSource(ds);
        if (!Play.configuration.getProperty("jpa.ddl", "update").equals("none")) {
            cfg.setProperty("hibernate.hbm2ddl.auto", Play.configuration.getProperty("jpa.ddl", "update"));
        }
        cfg.setProperty("hibernate.dialect", getDefaultDialect(Play.configuration.getProperty("db.driver")));
        cfg.setProperty("javax.persistence.transaction", "RESOURCE_LOCAL");
        if (Play.configuration.getProperty("jpa.debugSQL", "false").equals("true")) {
            org.apache.log4j.Logger.getLogger("org.hibernate.SQL").setLevel(Level.ALL);
        } else {
            org.apache.log4j.Logger.getLogger("org.hibernate.SQL").setLevel(Level.OFF);
        }
        // inject additional hibernate.* settings declared in Play!
        // configuration
        cfg.addProperties((Properties) Utils.Maps.filterMap(Play.configuration, "^hibernate\\..*"));

        try {
            Field field = cfg.getClass().getDeclaredField("overridenClassLoader");
            field.setAccessible(true);
            field.set(cfg, Play.classloader);
        } catch (Exception e) {
            Logger.error(e, "Error trying to override the hibernate classLoader (new hibernate version ???)");
        }
        for (Class<? extends Annotation> clazz : classes) {
            if (clazz.isAnnotationPresent(Entity.class)) {
                cfg.addAnnotatedClass(clazz);
                Logger.trace("JPA Model : %s", clazz);
            }
        }
        String[] moreEntities = Play.configuration.getProperty("jpa.entities", "").split(", ");
        for (String entity : moreEntities) {
            if (entity.trim().equals(""))
                continue;
            try {
                cfg.addAnnotatedClass(Play.classloader.loadClass(entity));
            } catch (Exception e) {
                Logger.warn("JPA -> Entity not found: %s", entity);
            }
        }
        Logger.trace("Initializing JPA ...");
        EntityManagerFactory entityManagerFactory = cfg.buildEntityManagerFactory();
        return entityManagerFactory.createEntityManager();
    }
}
